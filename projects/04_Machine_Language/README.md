## 🎯 04. 기계어 (Machine Language)

### 1. 목표
기계가 직접 이해할 수 있는 0과 1로 이루어진 핵(Hack) 기계어의 구조를 학습했다. 상징적인 문자로 작성된 어셈블리 명령어가 어떻게 16비트 바이너리 코드로 변환되는지 이해하고, 이를 이용해 간단한 프로그램을 작성하여 하드웨어 위에서 소프트웨어가 동작하는 첫 단계를 경험했다.

---

### 2. 핵 컴퓨터 아키텍처 (Hack Computer Architecture)
핵 컴퓨터는 폰 노이만 구조와 하버드 구조의 특징을 일부 가지는 **16비트 컴퓨터**이다.

* **메모리(Memory)**: **데이터 메모리(RAM)**와 **명령어 메모리(ROM)** 두 개를 사용하는 하버드 아키텍처를 따른다.
    * 두 메모리 모두 워드(word) 폭은 **16비트**, 주소 공간은 **15비트**($2^{15} = 32,768$개)이다.
    * 데이터 메모리는 읽고 쓰기가 가능하지만, 명령어 메모리는 읽기 전용이다.

* **레지스터(CPU Registers)**: CPU 내에는 D, A, M 세 종류의 핵심 레지스터가 존재한다.
    * **D 레지스터**: 16비트 값을 임시로 저장하는 순수한 **데이터 레지스터**이다.
    * **A 레지스터**: 데이터 값 또는 **주소**(RAM 주소, ROM 주소)를 저장하는 복합적인 레지스터이다. 상수를 불러오거나 특정 메모리 위치를 선택하는 데 사용된다.
    * **M 레지스터**: 가상의 레지스터로, 실제로는 A 레지스터가 가리키는 주소의 데이터 메모리 값, 즉 **`RAM[A]`**를 의미한다. 이를 통해 메모리를 레지스터처럼 간편하게 다룰 수 있다.

---

### 3. 핵 기계어 명세 (Hack Machine Language Specification)
모든 핵 기계어 명령어는 16비트로 이루어지며, A-명령어와 C-명령어 두 종류로 나뉜다.

#### A-명령어 (A-Instruction)
A-명령어는 A 레지스터에 15비트 값을 적재(load)한다. 주소로 사용하거나 상수로 사용할 수 있다. 기계어의 첫 비트가 `0`이면 A-명령어이다.

**구조: `0vvv vvvv vvvv vvvv`**
* `v`: 15비트 값 (0 ~ 32767)

#### C-명령어 (C-Instruction)
C-명령어는 실제 연산을 수행한다. 기계어의 첫 세 비트가 `111`이면 C-명령어이다. 나머지 13비트는 연산(comp), 저장(dest), 점프(jump) 세 부분으로 나뉜다.

**구조: `111a cccc ccdd djjj`**
* **comp (연산, 7 bits: `a` `c1`~`c6`)**: ALU에서 어떤 연산을 수행할지 결정한다.
    * `a` 비트가 `0`이면 `A` 레지스터를, `1`이면 `M` 레지스터(`RAM[A]`)를 연산에 사용한다.
    * `c` 비트들은 `0`, `1`, `D`, `A`, `!D`, `D+A`, `D-1` 등 구체적인 연산 종류를 지정한다.
* **dest (저장, 3 bits: `d1` `d2` `d3`)**: comp의 연산 결과를 어디에 저장할지 결정한다.
    * `d1`=1: A 레지스터에 저장
    * `d2`=1: D 레지스터에 저장
    * `d3`=1: M 레지스터(`RAM[A]`)에 저장
* **jump (분기, 3 bits: `j1` `j2` `j3`)**: comp의 연산 결과에 따라 프로그램의 다음 실행 위치로 점프할지 결정한다.
    * 결과가 0보다 작은지(`JLT`), 0인지(`JEQ`), 0보다 큰지(`JGT`) 등의 조건을 조합하여 분기한다.

---

### 4. 특이사항 및 배운 점 (Notes)
**추상화의 이면을 엿보다**: 평소 당연하게 사용하던 `if`, `while`, `for`와 같은 고수준 언어의 제어문이 실제 기계에서는 어떻게 동작하는지 어렴풋이나마 알게 되었다. 특히, **무한 루프**를 구현하기 위해 어셈블리어에서는 특정 주소로 계속해서 **점프(jump)하는 원초적인 방식**을 사용한다는 것을 직접 경험했다. 이는 우리가 사용하는 편리한 코드들이 결국 CPU가 이해할 수 있는 단순한 연산과 분기 명령어들의 조합으로 이루어져 있다는 사실을 깨닫게 해주었다. 

**앞으로의 학습 계획**: 이번 프로젝트를 통해 컴퓨터 구조의 가장 기본적인 층을 경험했다. 이 지식을 바탕으로, 더 발전된 아키텍처를 이해하기 위해 다음 두 가지 프로젝트를 진행하며 학습을 이어나가려 한다.

- **MIPS 아키텍처 학습**: 'Computer Organization and Design' (MIPS 버전) 책을 통해 현대 CPU와 RISC에 대해서 공부한다.
- **Mano's Computer 설계**: 'Computer System Architecture' (Mano) 책을 기반으로, 기본 컴퓨터를 직접 설계하고 시뮬레이션하며 CPU의 데이터 경로와 제어 유닛의 작동 원리를 더 깊이 파고들 계획이다.

**[➡️ 관련 프로젝트 저장소 링크 (추가 예정)]**