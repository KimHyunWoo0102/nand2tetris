## 🎯 06. 어셈블러 (Assembler)

---

### 1. 목표

6장의 과제를 기반으로 4장에서 배운 어셈블리어를 기계어로 번역하는 Hack Assembler를 구현한다. Hack 어셈블리 언어로 작성된 프로그램을 16비트 2진 코드로 변환하여 Hack 가상 컴퓨터에서 실행할 수 있는 실행 파일을 생성한다.

------



### 2. 프로젝트 API 

---

#### 1. `Parser.h`

`Parser` 클래스는 `.asm` 파일을 읽고 명령어를 한 줄씩 파싱하는 역할을 한다.

| 함수                   | 반환 타입         | 설명                                                         |
| ---------------------- | ----------------- | ------------------------------------------------------------ |
| `Parser(filename)`     | 생성자            | 주어진 `filename`의 파일을 열어 파서를 초기화한다.           |
| `advance()`            | `bool`            | 다음 명령어를 읽어와 공백과 주석을 지운다. 파일의 끝에 도달하면 `false`를 반환한다. |
| `reset()`              | `void`            | 파일 포인터를 파일의 시작 지점으로 되돌린다. 어셈블러의 2-way 패스를 위해 사용한다. |
| `getInstructionType()` | `instructionType` | 현재 명령어의 타입을 반환한다. (`A_INSTRUCTION`, `C_INSTRUCTION`, `L_INSTRUCTION`). |
| `symbol()`             | `std::string`     | `@xxx` 또는 `(xxx)` 명령어에서 심볼 `xxx`를 반환한다.        |
| `dest()`               | `std::string`     | `dest=comp;jump` 명령어에서 `dest` 부분을 반환한다.          |
| `comp()`               | `std::string`     | `dest=comp;jump` 명령어에서 `comp` 부분을 반환한다.          |
| `jump()`               | `std::string`     | `dest=comp;jump` 명령어에서 `jump` 부분을 반환한다.          |
| `getCurrentCommend()`  | `std::string`     | 현재 파싱된 명령어 줄을 반환한다.                            |

---

#### 2. `Code.h`

`Code` 클래스는 명령어 니모닉을 2진 코드로 변환하는 헬퍼 함수들을 제공하는 **싱글톤(Singleton)** 클래스이다.  

| 함수             | 반환 타입      | 설명                                                    |
| ---------------- | -------------- | ------------------------------------------------------- |
| `getInstance()`  | `static Code&` | `Code` 클래스의 유일한 인스턴스에 대한 참조를 반환한다. |
| `dest(mnemonic)` | `std::string`  | `dest` 니모닉을 3비트 2진 코드로 변환한다.              |
| `comp(mnemonic)` | `std::string`  | `comp` 니모닉을 7비트 2진 코드로 변환한다.              |
| `ump(mnemonic)`  | `std::string`  | `jump` 니모닉을 3비트 2진 코드로 변환한다.              |

------



#### 3. `HackAssembler.h`

`HackAssembler` 클래스는 어셈블러의 핵심 로직을 담당하며, `Parser`, `Code`, `mnemonic` 클래스들을 통합하여 어셈블리 과정을 실행한다.

| 함수              | 반환 타입 | 설명                                                         |
| ----------------- | --------- | ------------------------------------------------------------ |
| `HackAssembler()` | 생성자    | 어셈블러를 초기화하고 파일 입출력을 설정한다.                |
| `mapping()`       | `void`    | **첫 번째 패스**. `.asm` 파일을 스캔하여 모든 레이블의 주소를 심볼 테이블에 매핑한다. |
| `Assemble()`      | `void`    | **두 번째 패스**. 완성된 심볼 테이블을 사용해 모든 명령어를 2진 코드로 변환한다. |

---



### 배운 점 및 소감



이 프로젝트를 통해 어셈블러를 만들며 컴퓨터의 가장 기본적인 동작 원리를 알게 되었다. 

어셈블리 언어로 작성된 코드가 어떻게 2진 코드로 변환되어 컴퓨터가 이해하는지 그 과정을 직접 구현해보았다.

- **코드 구성 방법**: `Parser`, `Code`, `HackAssembler`와 같이 클래스를 나누고 각각의 역할에 맞게 코드를 구성하는 방법을 배웠다. 이렇게 코드를 모듈화하면 나중에 수정하거나 기능을 추가하기 훨씬 편하다는 걸 깨달았다. 다만 클래스 설계 등을 배운적이 없다보니 추후 UML, 디자인패턴 공부후 리펙토링을 해보고 싶다.

  

- **문자열 파싱**: 어셈블리 코드를 읽고 필요한 부분만 추출하는 문자열 파싱 기술을 배웠다. 주석이나 공백을 없애고, `dest`, `comp`, `jump` 같은 명령어의 각 부분을 정확히 찾아내는 과정은 생각보다 훨씬 복잡했지만, 덕분에 문자열을 다루는 실력이 늘었다.

- **테스트 및 디버깅의 중요성**: 코드를 작성하고 테스트하는 과정에서 수많은 오류를 만났다. 특히, `DM`과 `MD`처럼 작은 표기법 차이 때문에 프로그램이 작동하지 않는 문제를 해결하면서 디버깅의 중요성을 절실히 느꼈다. 

  좋은 테스트 코드 및 예외 처리를 통해 어느 부분에서 오류가 발생했는지 어떤 로직이 문제였는지를 빠르게 찾아내는 것이 중요하구나 느꼈다.

  테스트 주도 코딩에 대해서 공부해보고 싶다는 생각이 들었다.