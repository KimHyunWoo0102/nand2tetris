## 🎯 03. 순차 논리 칩 (Sequential Logic)

### 1. 목표

D FF의 기본 구조와 원리를 이해한다. 메모리에서 클럭의 중요함을 이해하고 동기화의 원리를 이해한다. 

1,2장에서 구현한 칩과 D FF을 시작으로 레지스터, RAM, PC를 구현한다.



---

### 2. 내용

#### 클럭

![240B4E3E59058F0026](https://github.com/user-attachments/assets/ab31a6fd-7ca0-4eab-a906-66a9c0758f6a)


컴퓨터가 '상태'를 기억하고 값을 저장하려면, 시시각각 변화하는 전기 신호 중에서 특정 시점의 값만 정확히 포착하는 능력이 필요하다. 이를 위해 컴퓨터는 **'시간'**이라는 개념을 도입해야한다.

하지만 컴퓨터는 우리처럼 시간을 연속적인 흐름처럼 인식하지 못한다. 대신, 일정한 간격으로 '똑딱'거리는 시계추처럼 시간을 불연속적인 단위, 즉 **주기(Cycle)**로 나누어 인식합니다.

이 **클럭신호**를 만들어내는 부품이 바로 메인보드의 **오실레이터**다. 오실레이터 내부에 있는 **쿼츠에 특정 전압을 가하면, 수정이 가진 고유한 특성 덕분에 매우 안정적이고 일정한 주파수로 진동한다. 컴퓨터는 이 진동을 전기적인 ON/OFF 신호로 변환하여, 시스템 전체를 동기화 시킨다.



#### 엣지 트리거
<img width="1032" height="287" alt="img" src="https://github.com/user-attachments/assets/37060ec6-b823-48b3-ad1a-27f0950c78e8" />

규칙적인 **클럭** 신호를 만들었다면, 이제 이 신호를 이용해 '원하는 시점'에만 데이터가 저장되도록 제어해야 한다. 이 제어 방식을 **트리거링**이라고 한다. 트리거링은 언제 데이터를 저장할지 결정하는 '방아쇠' 역할을 하며, 여기에는 크게 두 가지 방식이 있다.

1. **레벨 트리거 **: 클럭이 'ON' 상태(High Level)인 **'동안'** 계속해서 입력을 받아들인다. 이는 마치 문이 열려있는 동안에는 언제든 사람이 드나들 수 있는 것과 같다.
2. **엣지 트리거 **: 클럭이 'OFF'에서 'ON'으로 (또는 'ON'에서 'OFF'으로) 바뀌는 **'찰나의 순간'**에만 입력을 딱 한 번 받아들인다. 이는 문이 열리는 바로 그 순간에만 사람이 들어갈 수 있는 것과 같다.



#### D 플립플롭
<img width="547" height="246" alt="image" src="https://github.com/user-attachments/assets/28d62196-94fa-45b0-8f80-d3046441b4f5" />


위 사진과 같이 NAND 게이트를 통해 D FF를 만들수 있다.

![4712_1](https://github.com/user-attachments/assets/455155a2-34ea-470c-b78b-45fe907f204f)



진리표는 다음과 같고 다음 클럭이 들어올때까지 이전값을 저장한다. 

### 2. 구현 내용

* **D 플립플롭 (DFF)**: 모든 순차칩의 기초로 사용한다. 내장되어 있는 D FF를 그대로 사용한다.

* **레지스터 (Register)**: DFF 16개를 병렬로 묶어 16비트 단위의 데이터를 저장하고 불러올 수 있는 레지스터를 구현했다. 'load' 비트를 통해 현재 값을 유지할지, 새로운 값으로 갱신할지를 결정하는 로직을 추가했다.

* **프로그램 카운터 (PC)**: 레지스터를 기반으로 하여 덧셈, 리셋, 로드 기능을 가진 프로그램 카운터를 설계했다. PC는 다음 명령어의 주소를 가리키는 CPU의 핵심 부품으로, 제어 비트에 따라 값을 1 증가시키거나, 특정 주소로 점프하거나, 0으로 초기화하는 동작을 수행했다.

* **RAM (Random Access Memory)**: 여러 개의 레지스터를 묶고 `DMux`와 `Mux`를 활용하여 주소(address) 입력에 따라 특정 레지스터를 선택하여 읽거나 쓸 수 있는 RAM을 구축했다. 16개의 DFF가 모여 16비트 레지스터가 되고, 이를 주소에 따라 바로 접근 가능하게 만들어 RAM이 완성되는 과정을 통해 메모리의 계층 구조를 이해했다.

---

### 3. 특이사항 및 배운 점 (Notes)

* **컴퓨터에 '시간'을 도입하다**: 컴퓨터에 시간이 주어진다면 정해진 시간에 모두 같이 작업을 하는 **동기화** 작업이 가능하다는 점을 알게되었다.

* **클럭 주기의 중요성과 물리적 한계**: 적절한 클럭 주기를 정하는 것이 왜 중요한지 깨달았다. 데이터가 게이트를 통과하고 회로를 따라 물리적으로 이동하는 데에는 시간이 걸린다. 만약 클럭 주기가 회로의 가장 긴 경로를 데이터가 통과하는 시간(propagation delay)보다 짧으면, 이전 연산이 채 끝나기도 전에 다음 연산이 시작되어 전체 시스템이 오작동하게 된다. 이를 통해 컴퓨터의 연산 속도가 하드웨어의 물리적 한계에 의해 결정된다는 점을 이해했다.
